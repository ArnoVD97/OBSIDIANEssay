```c
    NSMutableSet *set = [NSMutableSet new];

    [set addObject:@[@1,@2]];

    NSMutableArray *array = [@[@1]mutableCopy];

    [set addObject:array];

    NSLog(@"%@", set);

    [array addObject:@2];

    NSLog(@"%@", set);

    NSMutableSet *setA = [set copy];

    NSLog(@"%@", setA);
```

```c
**2023-06-01 17:19:32.614799+0800 容器类[15671:380036] {(**

        **(**

        **1**

    **),**

        **(**

        **1,**

        **2**

    **)**

**)}**

**2023-06-01 17:19:32.614858+0800 容器类[15671:380036] {(**

        **(**

        **1,**

        **2**

    **),**

        **(**

        **1,**

        **2**

    **)**

**)}**

**2023-06-01 17:19:32.614900+0800 容器类[15671:380036] {(**

        **(**

        **1,**

        **2**

    **)**

**)}**
```
以上的代码可以使set集合拥有相同的元素，我们知道对于一个集合来说，是不允许有相同的元素的，那么这么实现肯定是有错误的，是什么原因导致了这种错误呢
问题出现在以下两行代码中：
```objective-c
[set addObject:@[@1,@2]]; 
[set addObject:array];
```
第一行代码将一个 `NSArray` 对象 `@[@1,@2]` 添加到了 `set` 中。然而，由于 `NSArray` 是不可变的（immutable），`set` 实际上添加的是指向该数组对象的指针，而不是数组中的元素。因此，当后续添加 `array` 对象时，实际上是将同一个数组对象添加到了 `set` 中，这导致了重复元素的存在。
当你在 `array` 中添加一个元素 `@2` 之后，由于 `set` 中存储的是指向该数组的引用，`set` 会反映出这个变化。所以第二个 `NSLog` 语句输出的结果中包含了 `@2`。
接下来，代码执行了一次 `copy` 操作将 `set` 的内容复制到了一个新的 `NSMutableSet` 对象 `setA` 中。`copy` 操作会创建一个不可变的副本，所以 `setA` 变成了一个不可变的 `NSSet` 对象。由于 `NSSet` 不允许重复元素，所以在复制过程中重复的元素被删除
`
