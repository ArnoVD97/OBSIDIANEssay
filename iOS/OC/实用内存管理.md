[[内存管理]]
您可以采取一些实际步骤来使内存管理更容易，并帮助确保您的程序保持可靠和健壮，同时最大限度地减少其资源需求
# 使用setter/getter方法使内存管理更容易
如果你的类具有对象属性，你必须确保在使用时任何被赋值的对象都没有被释放，因此当对象被设置时，你必须声明其所有权，还必须确保释放当前持有任何值的持有权
有时它可能看起来很乏味或迂腐，但如果你始终如一地使用存取器（setter/getter）方法，内存管理出现问题的可能性就会大大降低。如果您在整个代码中使用`retain`和`release`实例变量，肯定做错了事情。
```objective-c
@interface counter:NSObject
@property (nonatomic, retain) NSNumber *count;
@end
```
该属性声明了两种存取方法，通常，您应该要求编译器合成这些方法
看看它们如何实现是有益的。
在“获取”访问器中，您只需返回合成的实例变量，因此无需`retain`或`release`：
``` objective-c
- (NSNumber *)count {
	return _count;
}
```
在“设置”方法中，如果其他人都遵循相同的规则，您必须假设新的计数可能随时被处理，因此您必须通过发送retain消息来获得对象的所有权，以确保它不会被处理。您还必须通过向其发送`release`消息来放弃对此处旧计数对象的所有权。（Objective-C中允许向`nil`发送消息，因此如果`_count`尚未设置，则实现仍将有效。）您必须在`[newCount retain]`之后发送此信息，以防两者是相同的对象——您不想无意中导致它被dealloc。
```objective-c
- (void)setCount:(NSNumber *)newCount {

    [newCount retain];

    [_count release];

    // Make the new assignment.

    _count = newCount;

}
```
## 使用setter/getter方法来设置属性值
假设您想实现一种方法来重置计数器。你有几个选择。第一个实现使用alloc创建NSNumber实例，因此您可以通过release来平衡它
```objective-c
- (void)reset {

    NSNumber *zero = [[NSNumber alloc] initWithInteger:0];

    [self setCount:zero];

    [zero release];

}
```
第二个使用方便的构造函数来创建一个新的NSNumber对象。因此，没有必要retain或release消息
```objective-c
- (void)reset {

    NSNumber *zero = [NSNumber numberWithInteger:0];

    [self setCount:zero];

}
```
请注意，两者都使用设置存取器方法。

以下几乎肯定会在简单情况下正常工作，但即使避开访问器方法可能很诱人，但这样做几乎肯定会在某个阶段导致错误（例如，当您忘记retain或release时，或者如果实例变量的内存管理语义发生变化）。
```objective-c
- (void)reset {

    NSNumber *zero = [[NSNumber alloc] initWithInteger:0];

    [_count release];

    _count = zero;

}
```
另请注意，如果您使用键值观察 ，那么以这种方式更改变量不符合KVO。
[[KVO]]
## 不要在init方法和dealloc方法中使用存取器方法