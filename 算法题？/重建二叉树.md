输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
![[Pasted image 20230613220230.png]]
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
示例 2:

Input: preorder = [-1], inorder = [-1]
Output: [-1]
## 递归
对于一棵树前序遍历的形式总是
根左右
中序遍历的形式总是
左根右
若在中序中定位到根结点就能知道左右子树节点的数目，对应到前序遍历的结果中，就能定位左右子树的前中序遍历结果
即递归构造出左右子树，再将两颗子树连接到根结点的左右位置
```c++
/**

* Definition for a binary tree node.

* struct TreeNode {

* int val;

* TreeNode *left;

* TreeNode *right;

* TreeNode(int x) : val(x), left(NULL), right(NULL) {}

* };

*/

class Solution {

public:

TreeNode* buildTreeHelper(vector<int>& preorder, int preStart, vector<int>& inorder, int inStart, int inEnd, unordered_map<int, int>& orderMap) {

if (preStart > preorder.size() - 1 || inStart > inEnd) {
//递归出口
return nullptr;

}
//提取出根结点的值将其赋值给Root节点
int root = preorder[preStart];
TreeNode* Root = new TreeNode(root);
//通过哈希表将该值对应在中序遍历的索引提取出来，此索引记录的是该根结点的位置，也可以用查找算法找到该节点的索引，但是哈希表更为简便，明天写一下C++的哈希表
int rootIndex = orderMap[root];
//左子树的长度为该根结点的索引减去中序遍历的起点
//这个可以用来算右
int leftLenth = rootIndex - inStart;

  
  

Root -> left = buildTreeHelper(preorder,preStart+1, inorder,inStart,rootIndex - 1,orderMap);

Root -> right = buildTreeHelper(preorder,preStart + leftLenth +1, inorder,rootIndex + 1, inEnd, orderMap);

return Root;

}

TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {

unordered_map<int, int> orderMap;

if(preorder.empty() || inorder.empty()) {

return nullptr;

}

for(int i = 0;i < inorder.size(); i++) {

orderMap[inorder[i]] = i;

}

return buildTreeHelper(preorder,0,inorder,0,inorder.size(),orderMap);

}

};
```