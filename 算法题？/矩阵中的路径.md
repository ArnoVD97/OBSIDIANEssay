给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![[Pasted image 20230614203112.png]]

 

示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
![[Pasted image 20230614210242.png]]
```c++
  
class Solution {

public:

bool dfs(vector<vector<char>>& board, string& word, int index,int x, int y) {

  
//这里判断的是当你的搜索长度和单词长度达到一致的时候就说明所有字符已经对上了，
if(index == word.length()) {

return true;

}

if(x<0 || x>=board.size() || y <0 || y>=board[0].size() || board[x][y] != word[index]) {

return false;

}

char temp = board[x][y];

board[x][y] = '@';

bool found = dfs(board, word, index + 1, x, y + 1) || dfs(board,word, index + 1, x + 1, y) || dfs(board,word,index + 1,x-1,y) || dfs(board, word,index + 1,x,y-1);

board[x][y] = temp;

return found;

}

bool exist(vector<vector<char>>& board, string word) {

if(board.empty()) {

return false;

}

for(int i = 0; i <= board.size(); i++) {

for(int j = 0; j <= board[0].size(); j++) {

if(dfs(board, word, 0, i, j)) {

return true;

}

}

}

return false;

}

};
```
